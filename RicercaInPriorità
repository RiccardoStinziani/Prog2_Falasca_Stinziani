from Collection.Graph.graph.Graph_AdjacencyList import GraphAdjacencyList
from Collection.priorityQueue.PQbinomialHeap import PQbinomialHeap
import random


def priorityVisit(graph):
    verticeMax = graph.getNodeMaxWeight()
    priorityQueue = PQbinomialHeap()
    priorityQueue.insert(verticeMax.getId(), verticeMax.getWeight())
    markedNodes = [verticeMax.getId]
    list = []

    while not priorityQueue.isEmpty():
        idNode = priorityQueue.findMax()                #DA FAREEEEEEEEEEEEEEEEEEEEEEEEEE nb farlo per tutte le code con prioritÃ 
        list.append(idNode)
        priorityQueue.deleteMax()                       #DA FARE
        adjacentNodes = graph.getAdj(idNode)
        for nodeIndex in adjacentNodes:
            if nodeIndex not in markedNodes:
                node = graph.getNode(nodeIndex)
                priorityQueue.insert(node.getId(), node.getWeight())
                markedNodes.append(nodeIndex)
    return list

def graphGenerator(numberOfNodes):
    graph = GraphAdjacencyList()

    for i in range(numberOfNodes):
        weight = random.randint(0, 100)
        graph.addNode(i, weight)

    nodes = graph.getNodes().copy()

    n = numberOfNodes
    while(n > 0):
        edgeNodes = []
        for j in range(2):
            startNode = random.randint(0, n - 1)
            edgeNodes.append(nodes.pop(startNode))
            n -= 1
        graph.insertEdge(edgeNodes[0].getId(), edgeNodes[1].getId())

    k = random.randint(numberOfNodes / 2)

    for i in range(k):
        n = numberOfNodes
        nodes = graph.getNodes().copy()
        node1 = nodes.pop(random.randint(0, n - 1)).getId()
        n -= 1
        node2 = nodes.pop(random.randint(0, n - 1)).getId()

        while(graph.isAdj(node1, node2) == False):
            node2 = nodes.pop(random.randint(0, n - 1))
            n -= 1

        graph.insertEdge(node1, node2)

    return graph


if __name__ == "__main__":

    print(priorityVisit(graphGenerator(5)))